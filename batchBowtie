#!/usr/bin/perl

=pod

=head1 batchBowtie

  takes SIMR Lims directory and send fastq from samples for alignment in parallel using SGE

=head1 SYNOPSIS

  batchBowtie [options] 
              [--bowtie bowtie_index]
              [--directories flowcell_1 flowcell_2 ...] or
              [--fastqs seq_file1.fastq seq_file1.fastq ...]
              [-- any extra parameter to pass to bowtie]

 Options:
  --help            brief help message
  --man             full documentation

  --destdir         destination dir to save the results (Def: ~/batchAlignement/aln_timeStamp)
  --sub_selection   smaller list of sample to use
  --excluded        sample to remove from the job

  --threads         number of cores to use with bowtie

  --queue           SGE queue to use (Def: all.q)
  --email           if set, will sent detail emails for all submissions

  --dryrun          print the jobs that will be sent to SGE

 Every options names can be abreviated to their smaller unique value (ie: -dir/--directories, -de/--destdir)

=head1 REQUIRED ARGUMENTS

=over 8

=item B<--directories>

Path to the location of a flowcells containting the fastq and the .csv file describing the samples (Generated by the SIMR LIMS system).
Multiple diretories can be passed (seperated by space)

=item B<--directories>

Alternatively, the path to the location of a series of fastq files.


I<Either a signle or both options can be specified>

=item B<--bowtie>

Path to the root of the bowtie index. If the environment variable BOWTIE_TX_INDEXES exists and points to the directory containing the bowtie indexes, only the name of the index can be provide

=back

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--destdir>

Name and location of the directory where the final bam files will be located

=item B<--dryrun>

Prints the jobs that will be run without exuting them

=item B<--sub_selection>

smaller list of sample to use
  
=item B<--excluded>

sample to remove from the job

=item B<--queue>

SGE queue to use (Def: all.q)

=item B<-->

Additional paramter to pass to bowtie. Will be taken literally. Need to be encloseed in double quotes with internal double quotes properly escaped.
For instance:

-- "-N 2 -k5 --ignore-quals"

will be added as is to the bowtie parameter list. Currenlty, bowtie2 is run with no extra arguments.

=back

=head1 DESCRIPTION

B<This program> will read the SIMR Lims generated directories of flowcells barcodes
in search of a file with the .csv extension (the Sample_Report.csv and other iteration previously used by the lims).
It will then use the sample name (in column 1) and associates the coressponding fastq file(s) (in column 3), one sample 
to many fastq files, even if located accross flowcells (as long as the flowcell directories are passed as argument to --directories).

Then, the fastq file(s) will be split in a tmp directory and aligned in parallel using bowtie using jobs sent
to the SGE queue. The mulitple bam files will then be merged and the results will be saved indivually as .bam files
using the sample named in hte .csv files The --dest-dir can be use to define a location to save the results,
otherwise, the ./bowtieBatch_DD/MM/YY:H:M:S directory will be created and will store the final bam files.

Alternatively, B<this program> will send all files passed to the --fastqs options for alignment to the Sun Grid
Engine manager

=head1 EXAMPLES

B<Dry Run>: Printing what will be run without runing it
batchBowtie --dryrun --bowtie Drosophila_melanogaster.BDGP5.71.min --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX /n/analysis/Blanchette/sha/MOLNG-61/C0K08ACXX --destdir Sex_n_Tudor'

B<Running>:
batchBowtie --bowtie Drosophila_melanogaster.BDGP5.71.min --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX /n/analysis/Blanchette/sha/MOLNG-61/C0K08ACXX --destdir Sex_n_Tudor'

B<debugging>
batchBowtie --bowtie Drosophila_melanogaster.BDGP5.73.min --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX --destdir temp --debug

batchBowtie --bowtie Drosophila_melanogaster.BDGP5.73.min --dir test  --destdir temp

=cut

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path remove_tree);
use POSIX qw/strftime/;
use Getopt::Long;
use Pod::Usage;
use Cwd;
use File::Spec::Functions;

use threads;
use threads::shared;
use Thread::Queue;

our ($man,$help,$debug,$dryrun,@prog_args);
our (@fastqs,@dirs,$ebwt,$extra,$DESTDIR,@sub_select,@excluded);
our ($threads,$queue,$email);

our $aligner = 'bowtie';

MAIN:{

  init();
  testIndex();
  my %res = getSample2Files() if @dirs;
  my %fqs = map{(basename($_,qw|.fastq .fastq.gz|),[$_])} @fastqs  if @fastqs;
  my %files = (%res,%fqs);
  
  my $q = Thread::Queue->new;
  $q->enqueue(keys %files);
  
  my $num_workers = scalar keys %files < $threads ?scalar keys %files : $threads; # no need to be wasteful :)    
  
  my @threads;
  for (1 .. $num_workers) {
    my ($thr) = threads->create(\&worker, $q,%files);
    push @threads, $thr;
  }
  
  $_->join for @threads;
  
  print("Results will be found in $DESTDIR\n") unless $dryrun;
  exit 0;
}

sub worker {
  my ($q,%res) = @_;
    
  while (my $exp = $q->dequeue_nb) {
    my ($tmp_dir) = splitFile($exp,$res{$exp});
    my ($align_jid,$tmpFiles) = alignFiles($exp,$tmp_dir);
    my ($merge_jid,$bam_file) = mergeBams($exp,$tmp_dir,$tmpFiles,$align_jid);
    my ($index_jid) = indexBams($exp,$bam_file,$merge_jid);
    spinQsub($exp,"rm -Rf $tmp_dir",'cleanUp',{$exp => [$index_jid]});
  }
}


sub testIndex{
  my $ori_ebwt = $ebwt;
  ## Expand tilde to full path, 
  $ebwt =~ s/~/$ENV{HOME}/;
  unless (-e "$ebwt.1.ebwt"){
    if (exists $ENV{BOWTIE_INDEXES}){
      $ENV{BOWTIE_INDEXES} =~ s/~/$ENV{HOME}/;
      $ebwt = -e "$ENV{BOWTIE_INDEXES}/$ebwt.1.ebwt" ? 
	"$ENV{BOWTIE_INDEXES}/$ebwt" : undef;
    } else {
      $ebwt = undef;
    }
  }
  
  die "Can't find bowtie transcript index $ori_ebwt\n" unless $ebwt;
  
}

sub getSample2Files {
  my %res2;
  
  for my $dir (@dirs){
    $dir = File::Spec->rel2abs($dir);
    
    my ($csv,@rest) = glob "$dir/*.csv";
    if (@rest){
      print STDERR "There is more than one CSV file in $dir->[0]\n";
      exit;
    } elsif (!$csv){
      print STDERR "There is no sample report sheet in $dir\n";
      exit;
    }

    open FH, $csv;
    my($filename, $dir, $suffix) = fileparse($csv);
    my ($f_i,$s_i,%res);
    while (<FH>){
      chomp;
      my @line = split /,/;
       if($. == 1){
	 ($f_i) = grep{$line[$_] eq 'output'} 0..$#line;
	 ($s_i) = grep{$line[$_] eq 'sample name'} 0..$#line;
	 next;
       }
      $res{$line[$f_i]} = $line[$s_i];
    }
    my @fastq = map{File::Spec->rel2abs($_)} glob "${dir}*[ACGT].fastq.gz";
    
    my %excluded = map{$_,1} @excluded if @excluded;
    
    @fastq = grep{!exists $excluded{$_}} @fastq;
    
    for my $path (@fastq){
      my($file) = fileparse($path);
      
      if (!exists $res{$file}){
        print STDERR "$file is not associated with a sample name\n";
      } else {
        push @{$res2{$res{$file}}},$path
      }
    }
  }
  if (@sub_select){
    my %sub = map{$_=>1} @sub_select;
    %res2 = map{$_=>$res2{$_}} grep{exists $sub{$_}} keys %res2;
  }
  return %res2
}

sub alignFiles {
  my $exp = shift();
  my $exp_dir = shift();
  
  opendir(my $dh,$exp_dir);
  my @files = grep{/\.\d+$/} readdir $dh;
  my $num = scalar @files;
  closedir $dh;
    
  my $bam_dir = "$exp_dir/bam";
  make_path($bam_dir) unless $dryrun;
  
  my $align_job = join(" ",
		       "id=\$(printf '${exp}.\%04d' \$((\$\{SGE_TASK_ID\}-1)));",
		       "$aligner",
		       "-S",
		       "-v 2",
		       "-a --best --strata",
		       "-p1",
		       "$extra",
		       "$ebwt",
		       "${exp_dir}/\$id",
		       "|samtools view -S -b -|samtools sort -o - ${exp}.\$\{SGE_TASK_ID\} > ${bam_dir}/\$id.bam",
		      );
  
  my $jid = spinQsubArray($exp,$align_job,$num,"align");
  return($jid,\@files);
}

sub spinQsubArray {
  my $exp = shift;
  my $job = shift();
  my $num = shift();
  my $type = shift();
  my %holders = %{shift()} if @_;
  
  $type ||= '';
    
  my $sge_out = "$DESTDIR/SGE_out";
  make_path($sge_out) unless $dryrun;

  my $com = "qsub";
  $com   .= " -hold_jid ".join(",",(keys %holders)[0] eq 'common'?map{@{$_}} values(%holders):@{$holders{$exp}})
    if exists($holders{$exp}) || exists($holders{common});
  $com   .= " -m e -M $email" if $email;
  $com   .= " -l mem_free=4G,h_vmem=4.2G";
  $com   .= " -j y -o $sge_out";
  $com   .= " -t 1-$num";
  $com   .= " -q $queue";
  $com   .= " -N ${type}_$exp";
  $com   .= " -V";
  $com   .= " -cwd";
  $com   .= " -terse";
  $com   .= " -b y";
  $com   .= " '$job'";
  
  print "$com\n";
  print "============>>>\n";
  
  next if $dryrun;
  
  open my $qsub,"-|",$com;
  my ($jid) = map{chomp;s/\..+//;$_} <$qsub>;
  close $qsub;
  return($jid);
}

sub spinQsub {
  my $exp = shift();
  my $job = shift();
  my $type = shift();
  my %holders = %{shift()} if @_;
  
  $type ||= '';
  
  my $sge_out = "$DESTDIR/SGE_out";
  make_path($sge_out) unless $dryrun;
  
  my $com = "qsub";
  $com   .= " -hold_jid ".join(",",(keys %holders)[0] eq 'common'?map{@{$_}} values(%holders):@{$holders{$exp}})
      if exists($holders{$exp}) || exists($holders{common});
  $com   .= " -m e -M $email" if $email;
  #$com   .= " -l mem_free=1G";
  $com   .= " -j y -o $sge_out";
  $com   .= " -q $queue";
  $com   .= " -N ${type}_$exp";
  $com   .= " -V";
  $com   .= " -cwd";
  $com   .= " -terse";
  $com   .= " -b y";
  $com   .= " '$job'";
  
  print "$com\n";
  print "============>>>\n";
  
  next if $dryrun;
  
  open my $qsub,"-|",$com;
  my ($jid) = map{chomp;s/\..+//;$_} <$qsub>;
  close $qsub;
  
  return($jid);
  
}

sub mergeBams {
  my $exp = shift;
  my $tmp_dir = shift;
  my @files = @{shift()};
  my $jid = shift;
  
  my $bam_dir = "$DESTDIR/bam";
  make_path($bam_dir) unless $dryrun;
  my $final_bam = "$bam_dir/${exp}.bam";
  
  my $job;
  if (scalar @files > 1){
    $job = "time samtools merge -@ 8 -f - $tmp_dir/bam/*.bam > $final_bam";
  } else {
    $job = "mv $tmp_dir/bam/*.bam $final_bam";
  }
  my $merge_jid = spinQsub($exp,$job,'merge',{$exp => [$jid]}) unless $debug;
  return($merge_jid,$final_bam);
}

sub splitFile {
  my $exp = shift;
  my @files = @{shift()};
  
  my %jobs;
  my %fastq_dirs;
  
  my $tmp_dir = "$DESTDIR/$exp/tmp";
  $fastq_dirs{$exp} =  $tmp_dir;
  make_path($tmp_dir) unless $dryrun;
    
  my $job = "split -l 10000000 -d -a4";
  
  ## Testing wether we deall with gzip or plain file (well... by the extension...)
  my @gz = grep {/\.gz$/} @files;
  unless (@gz){
    $job .= @files;
  } elsif (scalar @gz == scalar @files){
    my $fastqs = join(" ",@gz);
    $job = "gunzip -c $fastqs |  $job - $tmp_dir/$exp.";
  } else {
    print STDERR "Can't deal with a mixture of .gz and plain text fastq file";
    next;
  }
  
  ## Run this only if files are not already there
  ## Assume that if the first one exists (ie .0000)
  ## All of them are there)
  system $job unless (-e "$tmp_dir/$exp.0000");
  return($tmp_dir);
}

sub indexBams {
  my $exp = shift;
  my $bam_file = shift;
  my $hold_jid = shift;
  my $job = "samtools index $bam_file";
  my $index_jid = spinQsub($exp,$job,'index',{$exp => [$hold_jid]}) unless $debug;
  return $index_jid;
}


sub init {
  my $filename = basename($0);
  @prog_args = ($filename,@ARGV);
  print("Running as:\n",
	join(" ",@prog_args),"\n",
	">>>>>>\n\n"
       );

  GetOptions('debug'                 => \$debug,
	     'help|?'                => \$help,
	     'man'                   => \$man,
	     
	     'directories=s{,}'      => \@dirs,
	     'fastqs=s{,}'           => \@fastqs,

	     'bowtie=s'              => \$ebwt,
	     'destdir=s'             => \$DESTDIR,
	     
	     'excluded=s{,}'         => \@excluded,
	     'sub_selection=s{,}'    => \@sub_select,
	     
	     'threads=i'              => \$threads,
	     'email=s'               => \$email,
	     'queue=s'               => \$queue,
	     'dryrun'                => \$dryrun
	    ) or pod2usage(1);

  if ($help || !((@dirs || @fastqs) && $ebwt)){
    pod2usage(-exitstatus => 0, -verbose => 2);
  }elsif ($man){
    pod2usage(-exitstatus => 0, -verbose => 0);
  }

  $queue   ||= 'all.q';
  $threads ||= 8;
  $extra = join(' ',@ARGV);
  
  $DESTDIR ||= strftime('bowtieBatch_%Y-%m-%d_%H%M%S',localtime);
  make_path($DESTDIR) unless (-e $DESTDIR && -d $DESTDIR) || $dryrun;
  
  print STDERR "##########RUNNING IN DEBUGING MODE##########\n" if $debug;
}
__END__
